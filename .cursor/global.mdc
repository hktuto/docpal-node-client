# DocPal Node Client - Global Cursor Rules

## Project Overview
This is a monorepo containing multiple Nuxt applications and libraries for the DocPal Node Client project.

## Project Structure
- `apps/` - Contains Nuxt applications (web, docs)
- `libraries/` - Contains shared libraries (api)
- `packages/` - Contains shared packages
- Root level contains workspace configuration

## App-Specific Rules
- **apps/web**: See `.cursor/apps-web.mdc` for specific rules
- **apps/docs**: See `.cursor/apps-docs.mdc` for specific rules

## Technology Stack
- **Package Manager**: pnpm with workspace configuration
- **Frontend**: Nuxt 4.x with Vue 3, TypeScript

## General Rules

### TypeScript
- Use strict TypeScript configuration
- Prefer `interface` over `type` for object shapes
- Use explicit return types for public functions
- Enable all strict mode options in tsconfig.json

### Vue/Nuxt
- Use `<script setup lang="ts">` syntax for Vue components
- Prefer Composition API over Options API
- Use Nuxt auto-imports (don't manually import Vue composables)
- Use `definePageMeta()` for page metadata
- Use `defineProps()` and `defineEmits()` for component props/events

### File Naming
- **Use PascalCase for file names**: `MyComponent.vue`
- Use PascalCase for component names in templates
- Use camelCase for variables and functions
- Use UPPER_SNAKE_CASE for constants

### Nuxt File Path Naming
- Nuxt uses file path naming convention
- Example structure:
  ```
  invoice/
  ├── Header/
  │   └── index.vue
  ```
  Becomes: `InvoiceHeader` component
- Use descriptive folder names that translate to component names

### Component Structure
```vue
<template>
  <!-- Template content -->
</template>

<script setup lang="ts">
// Imports
// Props/Emits definitions
// Composables
// Computed/Reactive data
// Methods
// Lifecycle hooks
</script>

<style scoped>
/* Component styles */
</style>
```



### State Management
- Use Nuxt composables for local state
- Use `useState()` for reactive state
- Use `useCookie()` for persistent state
- Avoid Pinia unless absolutely necessary



### Documentation Synchronization
- **ALWAYS** review `apps/docs` after changes to `apps/web`
- Update getting-started guides when installation/setup changes
- Update code examples when patterns or APIs change
- Keep UI screenshots and references current
- Update feature descriptions when functionality changes
- Ensure documentation reflects current behavior
- Test documentation examples to ensure they work
- **Version sync**: Update docs version to match `apps/web/package.json` version
- **Content updates**: All changes in web app must be reflected in docs

### Performance
- Use lazy loading for components when appropriate
- Implement proper image optimization
- Use code splitting for large applications
- Minimize bundle size with tree shaking

### Testing
- Write unit tests for utilities and composables
- Use Vitest for testing framework
- Test components with Vue Test Utils
- Mock external dependencies

### Git Workflow
- Use conventional commits format
- Create feature branches from main
- Use descriptive commit messages
- Keep commits atomic and focused

### Environment Configuration
- Use `.env` files for environment variables
- Never commit sensitive data
- Use runtime config for public variables
- Validate environment variables on startup

### Documentation
- Write JSDoc comments for public APIs
- Document complex business logic
- Keep README files updated
- Use TypeScript for self-documenting code
- **CRITICAL**: After any update in `apps/web`, check if `apps/docs` documentation needs updating
- Update API documentation when endpoints change
- Update getting-started guides when setup process changes
- Update examples when code patterns change
- Keep screenshots and UI references current

### Security
- Validate all user inputs
- Sanitize data before rendering
- Use HTTPS in production
- Implement proper authentication/authorization

### Accessibility
- Use semantic HTML elements
- Provide alt text for images
- Ensure keyboard navigation
- Test with screen readers

### Browser Support
- Support modern browsers (last 2 versions)
- Use progressive enhancement
- Test on mobile devices
- Ensure cross-browser compatibility

## Common Patterns

### API Calls
```typescript
const { data, pending, error } = await useFetch('/api/endpoint', {
  method: 'POST',
  body: payload,
  headers: {
    'Content-Type': 'application/json'
  }
})
```

### Reactive State
```typescript
const count = useState('count', () => 0)
const user = useState<User | null>('user', () => null)
```

### Component Props
```typescript
interface Props {
  title: string
  description?: string
  items: string[]
}

const props = defineProps<Props>()
```

### Event Handling
```typescript
const emit = defineEmits<{
  update: [value: string]
  delete: [id: string]
}>()
```

### Form Handling
```typescript
const form = reactive({
  email: '',
  password: ''
})

const { validate } = useForm(form)
```

## Linting and Formatting
- Use ESLint with TypeScript rules
- Use Prettier for code formatting
- Configure editor to format on save
- Use consistent indentation (2 spaces)

## Debugging
- Use Nuxt DevTools for development
- Implement proper error boundaries
- Use console logging sparingly
- Use Vue DevTools for component debugging

## Deployment
- Use static generation when possible
- Implement proper build optimization
- Use CDN for static assets
- Monitor performance metrics

## Code Review Guidelines
- Check for TypeScript errors
- Verify responsive design
- Test accessibility features
- Review security implications
- Ensure proper error handling
- Check for performance issues
- **Verify documentation is updated** when web app changes are made
- Ensure API documentation matches implementation
- Check that examples in docs are current and working

## Dependencies
- Keep dependencies up to date
- Use exact versions for critical packages
- Audit dependencies regularly
- Prefer official packages over community ones

## Error Handling
- Use try-catch for async operations
- Implement proper error boundaries
- Show user-friendly error messages
- Log errors for debugging
- Handle network failures gracefully

## Performance Optimization
- Use `v-memo` for expensive computations
- Implement virtual scrolling for large lists
- Use `shallowRef` for large objects
- Optimize images and assets
- Use service workers for caching

## Security Best Practices
- Validate all inputs
- Sanitize user content
- Use HTTPS only
- Implement rate limiting
- Follow OWASP guidelines
- Use secure authentication methods

## Accessibility Guidelines
- Use semantic HTML
- Provide alt text for images
- Ensure keyboard navigation
- Use proper ARIA labels
- Test with screen readers
- Maintain color contrast ratios

## Internationalization
- Use translation keys consistently
- Support RTL languages if needed
- Format dates and numbers properly
- Handle pluralization correctly
- Test with different locales

## Content Strategy
- Use structured data for SEO
- Implement proper meta tags
- Use descriptive URLs
- Optimize for search engines
- Implement sitemaps

## Monitoring and Analytics
- Implement error tracking
- Monitor performance metrics
- Track user interactions
- Use analytics responsibly
- Respect user privacy

## Backup and Recovery
- Implement data backup strategies
- Test recovery procedures
- Document disaster recovery plans
- Use version control effectively
- Maintain deployment rollback procedures

---

